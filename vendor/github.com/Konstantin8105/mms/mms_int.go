// Code generated by mmsgen; DO NOT EDIT.

package mms

import (
	"fmt"
	"sort"
	"sync"
)

// IntsCache of slices
type IntsCache struct {
	mutex  sync.RWMutex
	ps     []poolIntsCache
	putarr []debugIntsCache
}

type poolIntsCache struct {
	p    *sync.Pool
	size int
}

type debugIntsCache struct {
	arr  *[]int
	line string
}

// Get return slice
func (c *IntsCache) Get(size int) []int {

	// lock
	c.mutex.Lock()
	defer func() {
		c.mutex.Unlock()
	}()

	// finding index
	index := c.index(size)

	// creating a new pool
	if index < 0 {
		c.ps = append(c.ps, poolIntsCache{
			p: &sync.Pool{
				New: func() interface{} {
					return make([]int, size)
				},
			},
			size: size,
		})
		// sort
		sort.SliceStable(c.ps, func(i, j int) bool {
			return c.ps[i].size < c.ps[j].size
		})

		// return
		index = c.index(size)
		return c.ps[index].p.New().([]int)
	}

	// pool is found
	arr := c.ps[index].p.Get().([]int)

	arr = arr[:size]

	// if Debug {
	if len(arr) != 0 && cap(arr) != size {
		panic(fmt.Errorf("not valid sizes: %d != %d", len(arr), size))
	}
	// }

	// 	if Debug {
	if len(arr) < size {
		panic(fmt.Errorf("not same sizes: %d != %d", len(arr), size))
	}
	if len(arr) != cap(arr) {
		panic(fmt.Errorf("not valid capacity: %d != %d", len(arr), cap(arr)))
	}
	if len(arr) != size {
		panic(fmt.Errorf("not valid len: %d != %d", len(arr), size))
	}
	// 	}

	for i, size := 0, len(arr); i < size; i++ {
		// initialization of slice
		arr[i] = 0
	}
	return arr
}

// Put slice into pool
func (c *IntsCache) Put(arr *[]int) {

	if cap(*arr) == 0 {
		// empty size
		return
	}
	if len(*arr) == 0 {
		// propably it is a dublicate putting
		return
	}

	// lock
	c.mutex.Lock()
	defer func() {
		c.mutex.Unlock()
	}()

	var (
		size  = cap(*arr)
		index = c.index(size) // finding index
	)

	if index < 0 {
		return
	}
	if index > len(c.ps) {
		return
	}
	if c.ps[index].size != size {
		return
	}

	if Debug {
		// check if putting same arr
		for i := range c.putarr {
			if c.putarr[i].arr != arr {
				continue
			}
			panic(fmt.Errorf(
				"Dublicate of Put.\n"+
					"Last is called in :\n%v\n"+
					"Present call in   :\n%v\n",
				c.putarr[i].line,
				called(),
			))
		}
		// change value of array
		for i := range *arr {
			(*arr)[i] = -42 // Magic value for easy debug
		}

		// store array
		c.putarr = append(c.putarr, debugIntsCache{
			arr:  arr,
			line: called(),
		})
		// temp := (make([]int,size))
		// arr = &temp
		if c.ps[index].size != size {
			panic(fmt.Errorf("not valid index of size: %d != %d", c.ps[index].size, size))
		}
	}
	c.ps[index].p.Put(*arr)
}

// return index with excepted size
func (c *IntsCache) index(size int) int {
	index := -1
	for i := range c.ps {
		if c.ps[i].size < size {
			continue
		}
		if c.ps[i].size == size {
			index = i
		}
		break
	}
	return index
}

// Reset internal structure.
// In debug case - better for founding double putting.
// In normal case - for memory management with different memory profile.
//
//	Example of code:
//	w := cache.Get(10)
//	defer func() {
//		if mms.Debug {
//			cache.Reset()
//		}
//	}
//	... // Put memory in cache in next lines of code
//
func (c *IntsCache) Reset() {
	// lock
	c.mutex.Lock()
	defer func() {
		c.mutex.Unlock()
	}()

	// remove
	c.ps = make([]poolIntsCache, 0)
	c.putarr = make([]debugIntsCache, 0)
}
